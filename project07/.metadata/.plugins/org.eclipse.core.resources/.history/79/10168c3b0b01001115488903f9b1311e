import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Random;

public class Manager {
	int in_nodes, mid_nodes, out_nodes;

	ArrayList<double[]> weights = new ArrayList<double[]>();
	double[] in;
	double[] mid;
	double[] out;

	public Manager(int input, int middle, int output) {

		in_nodes = input;
		mid_nodes = middle;
		out_nodes = output;

		in = new double[in_nodes];
		mid = new double[mid_nodes];
		out = new double[out_nodes];

		create_connections();
		double[] t = { 1.0, 0.25, -.5 };
		double[] test = run(t);

		for (int i = 0; i < test.length; i++) {
			System.out.println(test[i]);
		}
		train();

	}
	
	private void train(){
		double[] input = { 1.0, 0.25, -.5 };
		double[] target = {1.0, -1.0, 0.0};
		double[] act = run(input);
		while(euclidean(target, act) > .1){
			double[] o = o_errors(act, target);
			double[] m = m_errors(o);
			update_out(o);
			update_mid(m);
			
			act = run(input);
			for (int i = 0; i < act.length; i++) {
				System.out.println(act[i]);
			}
		}
	}
	
	private double[] m_errors(double[] o_deltas){
		double[] m_deltas = new double[mid.length];
		
		for(int i=0; i<mid.length; i++){
			double error = 0; 
			for(int k=0; k < o_deltas.length; k++){
				error = error + o_deltas[k] * mid[i];
			}
			m_deltas[i] = error * in[i];
		}
		return m_deltas; 
	}
	
	private void update_out(double[] o_delta){
		for(int i=0; i<o_delta.length; i++){
			for(int k=0; k<weights.size(); k++){
				if(weights.get(k)[1] == mid.length + in.length + i){
					weights.get(k)[2] = o_delta[i] * weights.get(k)[2]; 
				}
			}
		}
	}
	
	private void update_mid(double[] m_delta){
		for(int i=0; i<m_delta.length; i++){
			for(int k=0; k<weights.size(); k++){
				if(weights.get(i)[1] == in.length + i){
					weights.get(k)[2] = m_delta[i] * weights.get(k)[2];
				}
			}
		}
	}
	
	private double[] o_errors(double[] r, double[] t){
		double[] o_deltas = new double[r.length];
		for(int i=0; i<r.length; i++){
			double error = t[i] - r[i];
			o_deltas[i] = out[i] * error;
		}
		return o_deltas;
	}

	private void create_connections() {
		Random rand = new Random();
		for (int i = 0; i < in_nodes; i++) {
			for (int j = 0; j < mid_nodes; j++) {
				double n = rand.nextDouble();
				double[] n_con = { (double) i, (double) in_nodes + j, n  };
				weights.add(n_con);
				System.out.println(i + "   " + n_con[1] + "    " + n_con[2]);
			}
		}
		for (int i = 0; i < mid_nodes; i++) {
			for (int j = 0; j < out_nodes; j++) {
				double n = rand.nextDouble();
				double[] n_con = { (double) in_nodes + i,
						(double) mid_nodes + in_nodes + j, n };
				weights.add(n_con);
				System.out.println(n_con[0] + "   " + n_con[1] + "    " + n_con[2]);
			}
		}
	}

	public double[] run(double[] input) {
		in = input;

		for (int i = 0; i < mid.length; i++) {
			double sum = 0;
			for (int k = 0; k < weights.size(); k++) {
				if (weights.get(k)[1] == in_nodes + i) {
					sum = sum + in[(int) weights.get(k)[0]] * weights.get(k)[2];
				}
			}

			mid[i] = Math.tanh(sum);
		}
		for (int i = 0; i < out.length; i++) {
			double sum = 0;
			for (int k = 0; k < weights.size(); k++) {
				if (weights.get(k)[1] == in_nodes + mid_nodes + i) {
					sum = sum + mid[(int) weights.get(k)[0] - in_nodes]
							* weights.get(k)[2];
				}
			}

			out[i] = Math.tanh(sum);
		}

		return out;
	}
	
	public double euclidean(double[] a, double[] b){    // euclidean distnace 
		double result =0; 
		double sum=0; 
		for(int i=0; i<b.length; i++){
			double sub = a[i] - b[i];   // getting the difference between the two coensiding attributes 
			sum = sum + Math.pow(sub, 2); 					// raising it to a power of 2 and adding it to the other sums 
		}
		result  = Math.sqrt(sum);						// taking the square root of the sums 
		return 1/(1 + result);						// normalizing the number 
		
	}

}
